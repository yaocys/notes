# 排序算法

---

## 比较

| 排序算法 | 时间复杂度 |   最好情况    |   最差情况    | 空间复杂度 | 稳定性 | 备注                     |
| :------: | :--------: | :-----------: | :-----------: | :--------: | :----: | ------------------------ |
| 冒泡排序 |  O(n^2^)   |     O(n)      |    O(n^2^)    |    O(1)    |        |                          |
| 选择排序 |  O(n^2^)   |    O(n^2^)    |    O(n^2^)    |    O(1)    |   否   |                          |
| 插入排序 |  O(n^2^)   |     O(n)      |    O(n^2^)    |    O(1)    |        |                          |
| 希尔排序 | O(n log n) | O(n log^2^ n) | O(n log^2^ n) |    O(1)    |   否   | 对插入排序的改进         |
| 归并排序 | O(n log n) |  O(n log n)   |  O(n log n)   |    O(n)    |        |                          |
| 快速排序 | O(n log n) |  O(n log n)   |    O(n^2^)    |  O(log n)  |   否   | 分治法策略，对冒泡的改进 |
|  堆排序  | O(n log n) |  O(n log n)   |  O(n log n)   |    O(1)    |   否   |                          |
| 计数排序 |   O(n+k)   |    O(n+k)     |    O(n+k)     |    O(k)    |        |                          |
|  桶排序  |   O(n+k)   |    O(n+k)     |    O(n^2^)    |   O(n+k)   |        |                          |
| 基数排序 |   O(n*k)   |    O(n*k)     |    O(n*k)     |   O(n+k)   |        |                          |

> In-place：占用常数内存，不占用额外内存
>
> Out-place：占用额外内存
>
> 排序算法稳定性：排序前后两个相等的元素的相对位置不变，则排序稳定

<img src="C:\Users\yaosu\AppData\Roaming\Typora\typora-user-images\image-20220401202159938.png" alt="image-20220401202159938" style="zoom:60%;" />



## 插入排序

> 类似于扑克牌”理牌“，把序列中第一个元素看作有序序列，从第二个元素开始依次从后往前与每一个元素比较，并插入到合适的位置，以此类推

### 二分插入

## 希尔排序

> 先将整个待排序的记录序列分割成若干子序列分别进行插入排序，待整个序列中的记录基本有序时，再对全体记录依次进行直接插入排序

## 冒泡排序

> 

## 快速排序

> 1. 从数列中挑出一个元素，作为“基准”（pivot）
>
> 2. 重新排序数列，所有比基准值小的摆放着基准前面，所有比基准大的摆放在基准后面（相同任意（所以不稳定））
>
>    在这个分区退出后，该基准就处于数列的中间位置
>
>    这个称为**分区操作**
>
> 3. 递归地把前后两个子序列排序

## 选择排序

> 1. 在未排序序列中找到最小（大）的元素，存放到排序序列的起始位置
> 2. 从剩余数列中继续寻找最小（大）的元素，放在已排序列的末尾
> 3. 重复第2步，直到元素排序完毕
