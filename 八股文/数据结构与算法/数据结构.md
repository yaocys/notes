# 数据结构

### 二叉树

#### 完全二叉树

##### 完全二叉树

设二叉树深度为h，除第h层外，其余各层节点数都达到最大个数，第h层所有节点都连续集中在最左边

##### 满二叉树

除最后一层无任何子节点外，每一层上的所有节点都有两个子节点二叉树

> 层数为K，且结点总数是(2^k) -1

##### 满二叉树

## B树和B+树

### B树

*为什么会出现B树这种数据结构*

传统平衡二叉树：AVL树、红黑树，在一般情况下查询性能非常好但当数据非常大时，内存不够用，大部分数据只能存放在磁盘上，只有需要的数据才加载到内存中。程序大部分时间阻塞在IO上

* 平衡二叉树是通过旋转来保持平衡的，而旋转是对整棵树的操作，部分加载到内存中则无法完成旋转操作

* 其次，平衡二叉树的高度相对较大未log2 n，**这样逻辑上很近的节点实际可能非常远，无法很好地利用磁盘预读（局部性原理）**

B树每个节点存多个值，且一次分多个范围区间，提升了搜索效率

### B+树

B+树的不同之处在于

1. 所有的关键字存储字叶子节点出现，内部节点（非叶子节点）并不存储真正的data
2. 为所有的叶子节点增加了一个链指针

![img](https://upload-images.jianshu.io/upload_images/1446087-30b70aaa28403803.jpg?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

**B树的定义**

> 一种多路平衡查找树
>
> 类似于普通的平衡二叉树，但是允许每个节点有更多的子节点

* 每个节点最多有m-1个关键字（可以存有键值对）
* 根节点最少可以只有1个关键字
* 非根节点至少右m/2个关键字

> 即**根节点**关键字数量范围：1 <= k <= m-1
>
> **非根节点**关键字数量范围：m/2 <= k <= m-1

* **每个节点中的关键字都按从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，右子树中的所有关键字都大于它**
* **所有叶子节点都位于同一层**，或者说根节点到每个叶子节点的长度都相同
* 每个节点都存有索引和数据，也就key-value

> m表示阶数

**B树的插入**

需要判断当前节点key树是否满足定义，不满足则将这个节点分为左右两部分，中间节点放到父节点中

**特点**

1. 所有的键值（索引和数据）分布在整棵树中
2. 任何一个关键字出现且只出现一个节点中
3. 搜索可能在非叶子节点结束
4. 在关键字全集内做一次查找性能逼近二分查找

**B+树相对于B树的优势**

* 单一节点存储的元素更多，使得查询IO次数更少（**B+树单次磁盘 IO 的信息量大于B-树**）

  B+树更适合外部存储。内节点无data域，每个节点能索引的范围更大更精确

* 所有查询都要查找到叶子节点，查询性能稳定log2n（B树每个节点都可以查到数据，不稳定，最好O（1））

* 所有的叶子节点形成了一个有序链表，更加便于查找

* B+树叶节点两两相连可大大增加区间访问行，可使用在范围查询（而B树key和data在一起，无法区间查找）

## 红黑树

## 分隔

### 并查集

#### 操作

* union

  将两个集合连在一起

* find

  查找给定节点的祖先，可以的话，将集合的层数/高度降低

### 堆





