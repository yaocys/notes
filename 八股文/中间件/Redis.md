# Redis

## 基础数据类型

#### 有哪些数据类型

* 核心数据类型有5个，分别是：string、list、hashmap、set、zset
* 另还有bitmap等基于上述核心数据类型实现
* 5.0新增streams，是消息队列

#### set和zset有什么区别？

set

* 无序不可重复，一个集合最多232-1个元素
* 除对元素增删查改外，还支持对多个集合取交、并、差

zset

* 有序不可重复
* 会为每个元素设置一个分数，元素分数可相同

## 持久化

Redis支持RDB、AOF和`RDB-AOF`混合持久化三种持久化方式

### Redis DataBase

Redis默认采用的持久化方式，以快照形式将进程数据持久化到硬盘中

触发方式有两种：

1. 自动触发——通过配置项
2. 手动触发
   * SAVE命令：执行期间，Redis服务器将阻塞
   * BGSAVE命令：异步，创建子进程期间短暂阻塞

#### 优缺点

* 优点：

  生成紧凑的二进制文件，体积小，恢复数据速度快

* 缺点：

  BGSAVE每次运行都要fork操作创建子进程，属于重量级操作，不宜频繁执行，所以无法做到实时持久化

### Append Only File

解决了数据持久化的实时性，主流持久化操作

独立日志方式，记录了每次写入命令，重启时重新执行AOF文件中的命令来恢复数据

#### 流程

默认不开启，需要修改配置项

以文本格式写入命令

#### 优缺点

* 优点：

  与RDB持久化可能丢失大量数据相比，AOF持久化的安全性要高很多

  通过everysec选项，可以将数据丢失窗口限制在1s内

* 缺点：

  文本文件体积更大，执行文件中的命令恢复速度慢很多

  AOF重写时也需要创建子进程，在数据库体积较大时将占用大量资源，会导致服务器的短暂阻塞。

### RDB-AOF混合持久化

4.0引入，可通过配置项开启

- 像执行BGSAVE命令一样，根据数据库当前的状态生成相应的RDB数据，并将其写入AOF文件中
- 对于重写之后执行的Redis命令，则以协议文本的方式追加到AOF文件的末尾，即RDB数据之后

## 缓存

### 穿透

缓存中不存在的数据被大量请求，导致数据库压力巨大

**如何避免？**

1. 对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存

2. 对一定不存在的key进行过滤，拦截非法请求

   可利用布隆过滤器，将可能存在的数据hash到bitmap中

### 击穿

一份热点缓存失效的瞬间，进入大量请求，直达存储层，导致服务崩溃

**如何避免**

1. 使用互斥锁：当数据为空时，只让一个请求通过，去数据库拉取数据（无论结果都要释放锁）

   这个线程访问过后，缓存中的数据将被重建，届时其他线程就可以直接从缓存中取值

2. 永远不过期：物理不过期，但逻辑过期（后台异步线程去重建缓存）

### 雪崩

在某一时刻，缓存层无法继续提供服务，导致所有的请求直达存储层，造成数据库宕机

>  可能是缓存中有大量数据同时过期，也可能是Redis节点发生故障

**如何避免**

1. 不同的key，设置不同的过期时间，让缓存的时间点尽量均匀
2. 在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待
3. 做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时可以访问A2，A1缓存失效时间设置为短期，A2设置为长期
4. 构建高可用的Redis服务：哨兵/集群
5. 启用降级或熔断措施

## 布隆过滤器

布隆过滤器可以以很低的代价，估算出数据是否真实存在

> 存在可能不存在，不存在一定不存在

核心包括两部分：

1. 一个大型位数组Bitmap
2. 若干个不一样的哈希函数，每个哈希函数都能将哈希值算得比较均匀

### 工作原理

1. 添加key时，每个哈希函数都以此计算出一个哈希值

   再根据哈希值计算出一个位置，并将位数组中这个位置的值设置为1

2. 询问key时，按以上步骤算出位置，然后比对：

   * 几个位置中，有一个是0，那么不存在
   * 都是1，可能存在

### 优点

### 缺点

## 一致性

* 强一致性

* 弱一致性

  不承诺可以立即读到写入的值，也不承诺多久之后数据能够达到一致

  > 但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态

* 最终一致性

  是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态

### 更新or删除？

* 更新
  * 优点：不容易出现未命中
  * 缺点：频繁更新消耗性能；没被读到又更新了，浪费性能
* 删除
  * 优点：操作简单
  * 缺点：删除后，可能出现缓存未命中，需要重读数据库

更新可能出现脏数据的问题

### 先数据库or先缓存？

先更新数据库，再删除缓存影响更小。第二步失败，可采用重试机制

### 延时双删

### binlog





## 集群

