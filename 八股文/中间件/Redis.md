# Redis

## 基础数据类型

#### 有哪些数据类型

* 核心数据类型有5个，分别是：string、list、hashmap、set、zset
* 另还有bitmap等基于上述核心数据类型实现
* 5.0新增streams，是消息队列

#### set和zset有什么区别？

set

* 无序不可重复，一个集合最多232-1个元素
* 除对元素增删查改外，还支持对多个集合取交、并、差

zset

* 有序不可重复
* 会为每个元素设置一个分数，元素分数可相同

## 持久化

Redis支持RDB、AOF和`RDB-AOF`混合持久化三种持久化方式

### Redis DataBase

Redis默认采用的持久化方式，以快照形式将进程数据持久化到硬盘中

触发方式有两种：

1. 自动触发——通过配置项
2. 手动触发
   * SAVE命令：执行期间，Redis服务器将阻塞
   * BGSAVE命令：异步，创建子进程期间短暂阻塞

#### 优缺点

* 优点：

  生成紧凑的二进制文件，体积小，恢复数据速度快

* 缺点：

  BGSAVE每次运行都要fork操作创建子进程，属于重量级操作，不宜频繁执行，所以无法做到实时持久化

### Append Only File

解决了数据持久化的实时性，主流持久化操作

独立日志方式，记录了每次写入命令，重启时重新执行AOF文件中的命令来恢复数据

#### 流程

默认不开启，需要修改配置项

以文本格式写入命令

#### 优缺点

* 优点：

  与RDB持久化可能丢失大量数据相比，AOF持久化的安全性要高很多

  通过everysec选项，可以将数据丢失窗口限制在1s内

* 缺点：

  文本文件体积更大，执行文件中的命令恢复速度慢很多

  AOF重写时也需要创建子进程，在数据库体积较大时将占用大量资源，会导致服务器的短暂阻塞。

### RDB-AOF混合持久化

4.0引入，可通过配置项开启

- 像执行BGSAVE命令一样，根据数据库当前的状态生成相应的RDB数据，并将其写入AOF文件中
- 对于重写之后执行的Redis命令，则以协议文本的方式追加到AOF文件的末尾，即RDB数据之后

## 缓存

### 穿透

缓存中不存在的数据被大量请求，导致数据库压力巨大

**如何避免？**

1. 对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存

2. 对一定不存在的key进行过滤，拦截非法请求

   可利用布隆过滤器，将可能存在的数据hash到bitmap中

### 击穿

一份热点缓存失效的瞬间，进入大量请求，直达存储层，导致服务崩溃

**如何避免**

1. 使用互斥锁：当数据为空时，只让一个请求通过，去数据库拉取数据（无论结果都要释放锁）

   这个线程访问过后，缓存中的数据将被重建，届时其他线程就可以直接从缓存中取值

2. 永远不过期：物理不过期，但逻辑过期（后台异步线程去重建缓存）

### 雪崩

在某一时刻，缓存层无法继续提供服务，导致所有的请求直达存储层，造成数据库宕机

>  可能是缓存中有大量数据同时过期，也可能是Redis节点发生故障

**如何避免**

1. 不同的key，设置不同的过期时间，让缓存的时间点尽量均匀
2. 在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待
3. 做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时可以访问A2，A1缓存失效时间设置为短期，A2设置为长期
4. 构建高可用的Redis服务：哨兵/集群
5. 启用降级或熔断措施

## 布隆过滤器

布隆过滤器可以以很低的代价，估算出数据是否真实存在

> 存在可能不存在，不存在一定不存在

核心包括两部分：

1. 一个大型位数组Bitmap
2. 若干个不一样的哈希函数，每个哈希函数都能将哈希值算得比较均匀

### 工作原理

1. 添加key时，每个哈希函数都以此计算出一个哈希值

   再根据哈希值计算出一个位置，并将位数组中这个位置的值设置为1

2. 询问key时，按以上步骤算出位置，然后比对：

   * 几个位置中，有一个是0，那么不存在
   * 都是1，可能存在

### 优点

* 相比于其它的数据结构，布隆过滤器在空间和时间方面都有巨大的优势。布隆过滤器存储空间和插入/查询时间都是常数。不需要存储key

* 另外, Hash 函数相互之间没有关系，方便由硬件并行实现。布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势。

* 布隆过滤器可以表示全集，其它任何数据结构都不能；

* k 和 m 相同，使用同一组 Hash 函数的两个布隆过滤器的交并差运算可以使用位操作进行。

### 缺点

* 随着存入的元素数量增加，误算率随之增加。但是如果元素数量太少，则使用散列表足矣。

* 一般情况下不能从布隆过滤器中删除元素. 我们很容易想到把位列阵变成整数数组，每插入一个元素相应的计数器加1, 这样删除元素时将计数器减掉就可以了。然而要保证安全的删除元素并非如此简单。首先我们必须保证删除的元素的确在布隆过滤器里面. 这一点单凭这个过滤器是无法保证的。另外计数器回绕也会造成问题。

## 一致性

* 强一致性

* 弱一致性

  不承诺可以立即读到写入的值，也不承诺多久之后数据能够达到一致

  > 但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态

* 最终一致性

  是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态

### 更新or删除？

* 更新
  * 优点：不容易出现未命中
  * 缺点：频繁更新消耗性能；没被读到又更新了，浪费性能
* 删除
  * 优点：操作简单
  * 缺点：删除后，可能出现缓存未命中，需要重读数据库

更新可能出现脏数据的问题

### 先数据库or先缓存？

先更新数据库，再删除缓存影响更小。第二步失败，可采用重试机制

### 延时双删

### binlog





## 集群

