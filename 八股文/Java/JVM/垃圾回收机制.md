# 垃圾回收机制

## 简述

Java属于自动内存管理语言：程序员无须显式地去释放一个对象的内存，而是由虚拟机自动执行

JVM中有一个垃圾回收线程，它是低优先级的——只有在**虚拟机空闲或者当前堆内存不足**的时候，才会触发执行。扫描哪些没有被任何引用的对象，并将它们添加到要回收的集合中进行回收。

### GC

垃圾回收（Gabage Collection），内存处理是编程人员很容易出现问题的地方。错误的或者忘记内存回收会导致程序不稳定甚至崩溃。

Java提供的GC功能可以**自动监测对象是否超过作用域**从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法

对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。

通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是"可达的"，哪些对象是"不可达的"。当GC确定一些对象为"不可达"时，GC就有责任回收这些内存空间。

程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。

#### 引用类型

* 强引用：发生GC的时候不会被回收
* 软引用：有用但不必须的对象，发生内存溢出前会被回收
* 弱引用：有用但不是必须的对象，在下次GC时会被回收
* 虚引用：无法通过虚引用获得对象，作用是在GC时返回一个通知

### 回收

#### 哪些需要回收

运行期间的堆内存/方法区内存

* 引用计数方法

  被引用计数器加一，失效减一

  但是主流虚拟机都没有采用，主要原因是这个看似简单的方法有很多例外情况需要考虑，必须配合大量额外处理才能保证正确地工作

  > 譬如：很难解决对象间地相互循环引用问题

* 可达性分析方法

  通过一系列称为“GC Roots”的根对象作为其实节点集，从这些节点开始，根据引用关系向下搜索，搜索过程走过的路径称为“引用链”

  > 固定可作为GC Roots的对象包括以下几种：
  >
  > - 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
  > - 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。
  > - 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。
  > - 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。
  > - Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。
  > - 所有被同步锁（synchronized关键字）持有的对象。
  > - 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

### 垃圾回收算法

> * 部分收集：
>
>   1. 新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。
>
>   2. 老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集
>
>      >  目前只有CMS收集器会有单独收集老年代的行为
>
>   3. 混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集
>
>      >  目前只有G1收 集器会有这种行为。
>
> * 整堆搜集
>
>   整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集

#### 分代算法

> 分代收集理论——分代假说：
>
> 1. 弱分代假说：绝大多数对象都是都是朝生夕灭的
> 2. 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡

根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法

##### 如何工作

分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。

新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：

- 把 Eden + From Survivor 存活的对象放入 To Survivor 区；
- 清空 Eden 和 From Survivor 分区；
- From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。

每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。

老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。

#### 标记-清除算法

标记无用对象，然后进行清除回收。

缺点：效率不高，无法清除垃圾碎片。

#### 复制算法

##### 半区复制

按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。

缺点：内存使用率不高，只有原来的一半

> 实际上并不需要按照1∶1的比例来划分新生代的内存空间

##### Appel式回收

把新生代分为一块较大的Eden空间和两块较小的 Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1

> 任何人都没有办法100%保证每次回收都只有不多于10%的对象存活，因此Appel式回收还有一个充当罕见情况的“逃生门”的安 全设计，当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实 际上大多就是老年代）进行分配担保（Handle Promotion）

#### 标记-整理算法

标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存

## 垃圾收集器

### 新生代

* Serial
* ParNew
* parallel

### 老年代

* Serial Old

* CMS

  以牺牲吞吐量为代价来获得最短回收停顿时间

* Parallel Old

### 新生代和老年代

#### G1

面向服务器端应用，整堆回收器

## 参考

* [JVM常用垃圾回收器的特点、优劣势、使用场景和参数](https://www.cnblogs.com/javazhiyin/p/14866493.html)
* [Java GC 基础四——常用的垃圾回收器]([Java GC 基础四——常用的垃圾回收器 - 简书 (jianshu.com)](https://www.jianshu.com/p/ae8d506e76f2))