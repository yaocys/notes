# JVM

---

## 基本结构

<img src="C:\Users\yaosu\AppData\Roaming\Typora\typora-user-images\image-20220427084009041.png" alt="image-20220427084009041" style="zoom:80%;" />

### ClassLoader

负责加载字节码class文件

并且只负责加载，能否运行由Execution Engine决定

### Runtime Data Area

1. 程序计数器：

   * 是一块较小的内存空间，可看作使当前线程所执行的字节码的行号指示器

   * 每条线程都有一个独立的程序计数器

   * 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址

     如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。

2. Java虚拟机栈

   * 线程私有的，生命周期与线程相同

   * 每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（存储**局部变量表**、操作数栈、动态连接、方法出口等信息）

     每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程

3. 本地方法栈

   * 虚拟机栈为虚拟机执行Java方法（字节码）服务

     本地方法栈为虚拟机使用到的本地方法服务

   * Hot-Spot虚拟机直接将本地方法栈和虚拟机栈合二为一

4. Java堆

   * 是虚拟机所管理的内存中最大的一块

   * 被所有线程**共享**的一块内存区域，在虚拟机启动时创建

   * 此内存区域的唯一目的就是**存放对象实例**，“几乎”所有的对象实例都在这里分配内存

   * 物理上不连续的内存空间，逻辑上连续

     大对象（数组），多数虚拟机可能会要求连续内存空间

5. 方法区

   * 各个线程**共享**的内存区域

   * 存储已被虚拟机加载的**类型信息**、常量、静态变量、即时编译器编译后的代码缓存等数据

   * 运行时常量池（Runtime Constant Pool）是方法区的一部分

     Class文件中有一项是常量池表，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中

### Execution Engine

Class 文件被加载后，会把指令和数据信息放入内存中，Execution Engine 则负责把这些命令解释给操作系统，即将 JVM 指令集翻译为操作系统指令集

### Native Interface

负责调用本地接口，作用是调用不同语言的接口给 JAVA 用

---

## 如何运行？

---

## 内存

### 内存模型



#### 内存泄漏

程序运行过程中分配内存给临时变量，用完之后却没有被GC回收，始终占用着内存，既不能被使用也不能分配给其他程序

#### 内存溢出

程序运行过程中申请的内存大于系统能够提供的内存，导致无法申请带足够的内存

##### 什么情况下会发生

* 线程请求的栈深度大于虚拟机所允许的深度，抛出StackOverflowError异常
* 虚拟机在动态拓展栈时无法申请到足够地内存空间，则抛出OutOfMemoryError异常

##### 出现了如何排错
