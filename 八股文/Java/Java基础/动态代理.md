# 动态代理

## 静态代理

### 缺点

1. 一个静态代理类只能代理一个接口，如果有大量接口，就会产生很大的冗余
2. 不易维护，一旦接口更改，代理类和目标类都需要更改

## 是什么？

无需声明式的创建java代理类，而是在运行过程中通过反射机制，生成"虚拟"的代理类，被ClassLoader加载。

从而避免了静态代理那样需要声明大量的代理类。

## 为什么？

拓展和增强

## 怎么做？

一个典型的动态代理创建对象的过程可以分为以下4个步骤：

1. 通过实现`InvocationHandler`接口创建自己的调用处理器
2. 通过为`Proxy`类指定`ClassLoader`对象和一组interface创建动态代理类，即`Proxy`的`getProxyClass()`方法
3. 通过反射机制获取动态代理类的构造函数，其参数类型是调用处理器接口类型即对上一步获得的clazz对象调用`getConstructor()`
4. 通过构造函数创建代理类实例，此时需将调用处理器对象作为参数被传入

为了简化对象创建过程，`Proxy`类中的`newInstance`方法封装了2~4，只需两步即可完成代理对象的创建。

## 参考

- [动态代理大揭秘，带你彻底弄清楚动态代理](https://segmentfault.com/a/1190000040680716)