# Java基础

## 概述

### Java语言特点

1. 面向对象

2. 平台无关

   > 关键是JVM（Java虚拟机）
   >
   > Java源代码经编译器编译后生成的字节码文件，可以在不同平台下的JVM虚拟机上被翻译成相应的机器码执行

3. 支持多线程

   > C++ 语言没有内置的多线程机制，因此必须调用操作系 统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程 支持

4. 支持网络编程并且很方便

5. 编译与解释并行

### JDK、JRE和JVM

JDK是：Java开发工具包

JRE是：Java运行时环境

JVM是：Java虚拟机

它们三个是包含关系，自底向上，

JVM+类库+部署+用户接口工具包=JRE

JRE+Java语言+工具&工具API（例如javac编译程序、javadoc文档等）=JDK

<img src="C:\Users\yaosu\AppData\Roaming\Typora\typora-user-images\image-20220527021934539.png" alt="image-20220527021934539" style="zoom:67%;" />

## 语言细节

1. 一个Java文件里可以有多个类吗？

   可以，但是最多**只能有一个被public装饰的类**，而且这个类**类名必须与文件名保持一致**

### Java访问权限

三种访问符：private、protected、public，不加任何修饰符则为default

修饰**成员变量/方法**，四种访问权限含义如下：

* private：该成员可以被**该类内部成员**访问
* default：该成员可以被该类内部成员访问，也可以被**同一包下的其他类**访问
* protected：……还可以被**它的子类**访问
* public：该成员可以被**任意包下，任意类的成员**访问

修饰**类**时，两种访问权限：

* default：该类可以被同一包下的其他类访问
* public：该类可以被任意包下，任意类访问

### Java数据类型

   包括**基本数据类型**和**引用数据类型**

   > 基本数据类型8个，4小类：
   >
   > 1. 整数类型（byte/short/int/long）
   > 2. 浮点类型（float/double）
   > 3. 字符类型（char）
   > 4. 布尔类型（boolean）
   >
   > > 除布尔类型之外的其他7个类型，都可看做数字类型，并进行类型转换
   >
   > ![image-20220512204756467](C:\Users\yaosu\AppData\Roaming\Typora\typora-user-images\image-20220512204756467.png)
   >
   > 引用类型分三类：数组、类、接口
   >
   > **默认值均为null**
   >
   > > 引用类型本质上就是通过指针，指向堆中对象所持有的内存空间

5. int类型数据范围是多少？

   int类型占4字节（32位）范围是：-2^31^~2^31^-1

6. 全局变量和局部变量的区别？

   成员变量：

   1. 成员变量是在**类的范围里**定义的变量
   2. 成员变量有默认初始值
   3. 未被`static`修饰的成员变量也叫**实例变量**，它存储于对象所在的的**堆**内存中，生命周期与对象相同
   4. 被`static`修饰的成员变量也叫**类变量**，它存储于**方法区**中，生命周期与当前类相同

   > Java中其实没有真正的全局变量

   局部变量：

   1. 局部变量是在方法里定义的变量
   2. 局部变量没有默认初始值
   3. 局部变量存储于**栈**内存中，作用的范围结束，变量空间会自动释放

### 包装类

1. 为什么要有包装类？

   Java是面向对象的语言，其设计理念是“一切皆对象”。但8中基本数据类型却出现了意外，它们不具备对象的特性。正是为解决这一问题，Java为每个基本数据类型都定义了一个对应的引用类型，就是包装类

2. 说一说自动装箱、自动拆箱的应用场景

   JDK1.5提供的功能

   通过…可以大大**简化基本类型变量和包装类对象之间的转换过程**

> 自动装箱：可以把一个基本数据类型直接赋值给对应的包装类型
>
> 自动拆箱：可以把一个包装类型的对象直接赋值给对应的基本类型

3. ***int和Integer有什么区别，二者在做==运算时会得到什么结果？***

   int是基本数据类型，Integer是int的包装类。二者在做`==`运算时，==Integer会自动拆箱为int类型==

   届时，如果两个int值相等则返回true，否则就返回false

4. 如何对Integer和Double类型判断相等？

   Integer和Double不能直接比较

   整数、浮点类型的包装类，都继承于Number类型，而Number类型分别定义了将数字转换为byte、short、int、long、float、double的方法。

   所以，可以将Integer、Double先转为转换为相同的基本数据类型（如double），然后使用==进行比较。

> 包括：
>
> * 不能用`==`直接进行比较
> * 不能转为字符串进行比较，因为转字符串后，浮点值带小数点，整数值不带
> * 不能使用`compareTo`方法进行比较（该方法只能对相同类型进行比较）

### String

String类由final修饰，不能被继承

> 出于安全和性能考虑
>
> Java 9前采用`char[]`数组，后采用`byte[]`数组

1. String类有哪些常用方法？

   - `char charAt(int index)`：返回指定索引处的字符
   - `String substring(int beginIndex, int endIndex)`：从此字符串中截取出一部分子字符串
   - `String[] split(String regex)`：以指定的规则将此字符串分割成数组
   - `String trim()`：删除字符串前导和后置的空格
   - `int indexOf(String str)`：返回子串在此字符串首次出现的索引
   - `int lastIndexOf(String str)`：返回子串在此字符串最后出现的索引
   - `String toUpperCase()`：将此字符串中所有的字符大写
   - `String toLowerCase()`：
   - `String replaceFirst(String regex, String replacement)`：用指定字符串替换第一个匹配的子串
   - `String replaceAll(String regex, String replacement)`：用指定字符串替换所有的匹配的子串

2. String和StringBuffer

   String是不可变类

   而StringBuffer是一个字符序列可变的字符串，通过其成员方法（如`append()`）操作，并最终可通过`toString()`方法将其转换为一个字符串

3. StringBuffer和StringBuilder的区别

   StringBuffer是线程安全的，而StringBuilder是非线程安全的，所以StringBuilder性能略高。

4. 使用字符串时，new和“”两种方式

   1. `String a = "abc"`

      JVM使用常量池来管理字符串直接量。

      在执行这句话时，JVM会先检查常量池（方法区中）中是否已经存有"abc"，若没有则将"abc"存入常量池，否则就复用常量池中已有的"abc"，将其引用赋值给变量a。

   2. `new String("abc")`

      在执行这句话时，JVM会先使用常量池来管理字符串直接量，即将"abc"存入常量池。

      然后再创建一个新的String对象，这个对象会被保存在==堆==内存中。并且，堆中对象的数据会指向常量池中的直接量。

   一般建议使用直接量的方式创建字符串

5. ***字符串拼接***

   1. \+ 运算符：如果拼接的都是字符串直接量

      > * 如果拼接的都是字符串直接量，则在编译时编译器会将其直接优化为一个完整的字符串，和直接写一个完整的字符串是一样的，所以效率非常的高
      > * 如果拼接的字符串中包含变量，则在编译时编译器采用StringBuilder对其进行优化，即自动创建StringBuilder实例并调用其append()方法，将这些字符串拼接在一起，效率也很高。

   2. StringBuilder：如果拼接的字符串中包含变量，并不要求线程安全

   3. StringBuffer：如果拼接的字符串中包含变量，并且要求线程安全

      > - StringBuilder/StringBuffer都是==可变对象==，都有字符串缓冲区，缓冲区的容量在创建对象时确定，并且默认为16。当拼接的字符串超过缓冲区的容量时，会触发缓冲区的扩容机制，即缓冲区加倍。
      > - 可以指定缓冲区容量，避免频繁扩容降低拼接性能

   4. String类的concat方法：如果只是对两个字符串进行拼接，并且包含变量，则适合使用concat方法

      > * 先创建一个足以容纳待拼接的两个字符串的字节数组，然后先后将两个字符串拼到这个数组里，最后将此数组转换为字符串。
      > * 在拼接大量字符串的时候，concat方法的效率低于StringBuilder
   

## 异常

### 异常类接口

Throwable是异常类的顶层父类，代表所有的非正常情况，直接子类有两个，Error和Exception

* Error错误

  一般指与虚拟机相关的问题，这种问题无法恢复或不可能捕获，将导致应用程序中断

* Exception异常

  分为Checked异常和Runtime异常。

所有RuntimeException类及其子类的实例被称为Runtime异常，其余异常示例则被称为Checked异常

> Java认为Checked异常都是可以被处理（修复）的异常，所以Java程序必须显式处理Checked异常。否则，该程序在编译时就会发生错误，无法通过编译。
>
> Runtime异常则更加灵活，Runtime异常无须显式声明抛出，如果程序需要捕获Runtime异常，也可以使用try...catch块来实现。

### 处理异常

可以按照如下三个步骤处理异常：

1. 捕获：try…catch…
2. 处理异常：先记录日志
3. 回收资源：将关闭资源代码写在finally块中（无论是否发生异常，总会被执行）

### Java异常机制

* 异常处理：Java中异常处理语句由try（包裹业务代码）、catch（捕获并处理某个类型的异常）、finally（用于回收资源）三部分组成。

* 抛出异常：当程序出现错误时，系统会自动抛出异常。此外，也允许程序主动抛出异常（throw关键字）。throw将异常交给JVM处理

* 异常跟踪栈：程序运行时，经常会发生一系列方法调用，从而形成方法调用栈。异常机制会导致异常在这些方法之间传播，而异常传播顺序与方法的调用相反——从发生异常的方法向外传播，首先传给该方法的调用者，再传给上层调用者，以此类推。

  最终会传到main方法，若依然没有得到处理，则JVM会终止程序，并打印异常跟踪栈的信息

---

## 面向对象

1. 说一说对“面向对象”的理解

   “面向对象”是一种更优秀的程序设计方法，它的基本思想是：使用类、对象、继承、封装、消息等基本概念进行程序设计。

   相对于“面向过程”而言，它将具体的事物进行抽象，封装了它们的属性和操作（方法），从而无需事无巨细地每一次都要考虑操作的每一步具体细节

### 优点

* 易维护、易复用、易拓展
* 由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统

### 缺点

* 性能比面向过程更低

### 面向对象的三大特征

#### 封装

##### 是什么

封装是面向对象语言对客观世界的模拟，实际上有两个方面的含义：把该隐藏的隐藏起来，把该暴露的暴露出来

* 将对象的成员变量和实现细节隐藏起来，不允许外部直接访问
* 把方法暴露出来，让方法来控制对这些成员变量进行安全的访问和操作

##### 为什么

* 隐藏类的实现细节

* 限制对成员变量的不合理访问

  > 让使用者只能通过事先预定的方法来访问数据，从而可以在该方法里加入逻辑控制

* 可以进行数据检查，从而有利于保证对象信息的完整性

* 便于修改，提高代码的可维护性

#### 继承

##### 是什么

当子类继承父类后，子类作为一种特殊的父类，将直接获得父类的属性和方法

##### 为什么

* 代码复用的重要手段

#### 多态

##### 是什么

因为子类其实是一种特殊的父类，因此Java允许把==一个子类对象直接赋给一个父类引用变量==，无须任何类型转换，或者被称为向上转型，向上转型由系统自动完成

**编译时类型是父类，运行时类型是子类**，其方法行为总是表现出子类方法的行为特征，而不是父类方法的行为特征，这就可能出现：==相同类型的变量、调用同一个方法时呈现出多种不同的行为特征==——这就是多态

> 简单工厂模式

##### 意义

* 应用程序不必为每一个派生类都编写功能调用，只需要对抽象基类进行处理即可，大大提高了程序的可复用性

* 派生类的功能可以被基类的方法或者引用变量调用，向后兼容，可以提高程序的可扩展性和可维护性

##### 如何实现

多态的实现离不开继承，在设计程序时，我们可以==将参数的类型定义为父类型==。在调用程序时，则可以根据实际情况，==传入该父类型的某个子类型的实例==，这样就实现了多态。

对于父类型，可以有三种形式，即普通的类、抽象类、接口

对于子类型，则要根据它自身的特征，重写父类的某些方法，或实现抽象类/接口的某些抽象方法

   > 抽象也是面向对象的重要部分，指：忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面
   >
   > 抽象并不打算了解全部问题，而是只考虑部分问题

3. *** Java为什么是单继承，为什么不能多继承？***

    首先，Java是单继承的，是指：Java中一个类只能有一个直接父类。Java不能多继承，是指：Java中一个类不能直接继承多个父类

    其次，Java在设计时借鉴了C++的语法，而C++是支持多继承的。Java语言之所以摒弃了多继承的这项特征，是因为多继承容易产生混淆。

    >  比如，两个父类中包含相同的方法时，子类在调用该方法或重写该方法时就会迷惑。

    准确来说，Java是可以实现"多继承"的。因为尽管一个类只能有一个直接父类，但是却可以有任意多个间接的父类。这样的设计方式，避免了多继承时所产生的混淆。

### 重写和重载的区别

重载发生在同一个类中，若多个方法之间**方法名相同，参数列表不同**，则它们构成重载关系。重载**与方法的返回值及访问修饰符无关**

重写发生在父类的子类中，若子类方法想要和父类方法构成重写关系，则：

* 子类方法名、参数列表必须与父类方法相同
* 返回值、抛出异常要小于等于父类方法
* 访问修饰符要大于等于父类方法（若父类方法是private，则子类不能对其进行重写）

7. ***构造方法能不能重写？***

    不能，因为重写要求子类方法和父类方法同名，而构造方法需要和类保持同名，但子类和父类是不同的类不可能同名，所以矛盾了。

8. ***介绍一下Object类中的方法***

    Object类提供了如下几个常用方法：

    * `Class<?> getClass()`：返回该对象的运行时类

    * `boolean equals(Object obj)`：判断指定对象与当前对象是否相等

    * `int hashCode()`：返回该对象的hashCode值

      > Object类的hashCode()方法根据该对象的地址来计算。但很多类都重写了Object类的hashCode()方法，不再根据地址来计算其hashCode()方法值。

    * `String toString`：当程序使用`System.out.println()`方法输出一个对象，或者把某个对象和字符串进行连接运算时，系统都会自动调用该对象的此方法返回该对象的字符串表示

      Object类的toString()方法返回 运行时类名@十六进制hashCode值 格式的字符串

    另外，Object类还提供了`wait()`、`notify()`、`notifyAll()`方法，通过这几个方法可以控制线程的暂停和运行

    Object类还提供了一个clone()方法，该方法用于帮助其他对象来实现“自我克隆”，得到一个当前对象的副本，而且二者之间完全隔离。由于该方法使用了`protected`修饰，因此它只能被子类重写或者调用
    
    
    
10. 为什么要重写`hashCode()`和`equals()`

      Object类提供的equals()方法默认是用==来进行比较的，也就是说只有两个对象是同一个对象时，才能返回相等的结果。而实际的业务中，我们通常的需求是，若两个不同的对象它们的内容是相同的，就认为它们相等。鉴于这种情况，Object类中equals()方法的默认实现是没有实用价值的，所以通常都要重写。

      > 

### ==和`equals()`区别

 ==运算符：

  - 作用于基本数据类型时，是比较两个数值是否相等；
  - 作用于引用数据类型时，是比较两个对象的内存地址是否相同，即判断它们是否为同一个对象；

  equals()方法：

  - 没有重写时，Object默认以 == 来实现，即比较两个对象的内存地址是否相同；

  - 进行重写后，一般会按照对象的内容来进行比较

    ```java
    String s1 = "hello";
    String s2 = new String("hello");
    System.out.println(s1==s2);
    // false,比较的是引用
    System.out.println(s1.equals(s2));
    // true,比较的是各个字符
    // 也就是说String重写了equals方法  
    ```

### `hashCode()`和`equals()`

`hashCode()`用于获取哈希码（散列码），`eauqls()`用于比较两个对象是否相等，它们应遵守如下规定：

- 如果两个对象相等，则它们必须有相同的哈希码
- 如果两个对象有相同的哈希码，则它们未必相等

> 由于`hashCode()`与`equals()`具有联动关系，所以当由于业务需要重写了`equals()`方法，通常也要将hashCode()进行重写，使得这两个方法始终满足相关的约定

## 接口

### 接口和抽象类

#### 相同点：

 * 都不能被实例化，只能被实现/继承
* 都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法

#### 不同点

##### 概念上

* 接口体现的是一种规范

     对于接口的实现者而言，接口规定了实现者必须向外提供哪些服务；对于接口的调用者而言，接口规定了调用者可以调用哪些服务，以及如何调用这些服务。

     > 当在一个程序中使用接口时，接口是多个模块间的耦合标准；当在多个应用程序之间使用接口时，接口是多个程序之间的通信标准

* 抽象类体现的是一种模板式设计

     抽象类作为多个子类的抽象父类，可以被当成系统实现过程中的中间产品，这个中间产品已经实现了系统的部分功能，但这个产品依然不能当成最终产品，必须有更进一步的完善，这种完善可能有几种不同方式。

##### 具体

   * 接口里只能包含抽象方法、静态方法、默认方法和私有方法，不能为普通方法提供方法实现

     抽象类可以包含普通方法

   * 接口里只能定义**静态常量**

     抽象类中还可以定义**普通成员变量**

   * 接口里**不包含构造器**；抽象类里可以包含构造器

     > 抽象类里的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作

   * 一个类最多只能有一个直接父类，包括抽象类；但一个类可以直接实现多个接口，通过实现多个接口可以弥补Java单继承的不足

#### 面向接口编程

降低模块间耦合，提升系统地可拓展性和可维护性

## 泛型

Java集合有个缺点：把一个对象“丢进”集合里之后，集合就会“忘记”这个对象的数据类型，当再次取出该对象时，该对象的编译类型就变成了Object类型（其运行时类型没变）

之所以被设计成这样，是因为集合的设计者不知道我们会用集合来保存什么类型的对象，所以他们把集合设计成能保存任何类型的对象，只要求具有很好的通用性。但这样做带来如下两个问题：

- 集合对元素类型没有任何限制，这样可能引发一些问题。例如，想创建一个只能保存Dog对象的集合，但程序也可以轻易地将Cat对象“丢”进去，所以可能引发异常。
- 由于把对象“丢进”集合时，集合丢失了对象的状态信息，只知道它盛装的是Object，因此取出集合元素后通常还需要进行强制类型转换。这种强制类型转换既增加了编程的复杂度，也可能引发ClassCastException异常。

从Java 5开始，Java引入了“==参数化类型==”的概念，允许程序在创建集合时指定集合元素的类型，即为“泛型”

### 好处

编译时检查类型安全，且所有的强制转换都是自动和隐式的，以提高代码的重用率

### 泛型擦除

当把一个具有泛型信息的对象赋给另一个没有泛型信息的变量时，所有在尖括号之间的类型信息都将被扔掉

> 反过来没有问题，称为“泛型转换”

- ? 是类型通配符，List<?> 可以表示各种泛型List的父类，意思是元素类型未知的List；
- List<? super T> 用于设定类型通配符的下限，此处 ? 代表一个未知的类型，但它必须是T的父类型；
- List<? extends T> 用于设定类型通配符的上限，此处 ? 代表一个未知的类型，但它必须是T的子类型。

## 反射机制

#### 什么是反射?

反射就是 在程序运行期间,动态地获取对象的属性和方法的功能

获取Class对象有4种方法

1. Class.forName("类路径")
2. 类名.class
3. 对象名.getClass()
4. 基本类型的包装类，可以调用包装类的Type属性来获得该包装类的Class对象

优点：运行期间能够动态地获取类，提高代码的灵活性

缺点：性能比直接的Java代码差很多

> 要解析字节码，通过类加载器创建

应用场景：

* Spring的XML配置模式

* 动态代理

* JDBC

  ```java
  class.forName('com.mysql.jdbc.Driver.class')
  ```

  

### 变量类型

#### 全局变量

在类中，分两类：

* 类变量（静态变量）

  有static修饰

* 实例变量

  无static修饰

  ##### 区别：

  1. 生命周期不同

     类变量随类的加载而创建

     实例变量随对象的创建而创建，随对象的销毁而销毁

  2. 调用方式不同

     类变量可以由对象调用，也可以由类名直接调用

     实例变量只能由对象调用

  3. 存储位置不同

     类变量存在**方法区**

     实例变量存在**堆**中

#### 局部变量

在方法中，随方法的执行被创建，作用域（方法）结束即销毁

### Lambda表达式

可以替代匿名内部类，本质是一个匿名函数

### 浅拷贝和深拷贝

#### 引用拷贝和对象拷贝

* 引用拷贝

  创建一个指向被拷贝对象的引用，对象仍然只有一个

  <img src="C:\Users\yaosu\AppData\Roaming\Typora\typora-user-images\image-20220709004900522.png" alt="image-20220709004900522" style="zoom: 33%;" />

* 对象拷贝

  创建一个对象的拷贝，一共两个对象

  <img src="C:\Users\yaosu\AppData\Roaming\Typora\typora-user-images\image-20220709005006479.png" alt="image-20220709005006479" style="zoom:33%;" />

#### 浅拷贝

#### 深拷贝

## 参考



