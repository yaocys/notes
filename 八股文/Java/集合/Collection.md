# 集合类

---

### 1. Map、List和Set有什么区别？

Set代表**无序**、**不可重复**的元素集合

List代表**有序、可重复**的元素集合

Map代表**具有映射关系（即key-value键值对）**的集合，其所有的key是一个Set集合，即key无序且不可重复

## LIst

### 2. ArrayList和LinkedList区别

1. `ArrayList`的实现是基于==动态数组==，`LinkedList`的实现是基于==双向链表==
2. 随机访问、查找时间复杂度：O（1）/O（N）
3. 插入和删除操作，LinkedList要优于ArrayList，因为ArrayList要重新计算大小或者更新索引
4. LinkedList更占内存，因为还要额外存储两个引用，分别指向前后元素

### 有哪些线程安全的List

1. Vector，古老API不建议使用，性能差

2. Collections.SynchronizedList

3. CopyOnWriteArrayList

   是Java 1.5在java.util.concurrent包下增加的类，它采用复制底层数组的方式来实现写操作。

   当线程对此类集合执行读取操作时，线程将会直接读取集合本身，无须加锁与阻塞。

   当线程对此类集合执行写入操作时，集合会在底层复制一份新的数组，接下来对新的数组执行写入操作。由于对集合的写入操作都是对数组的副本执行操作，因此它是线程安全的。

   在所有线程安全的List中，它是性能最优的方案。

### ArrayList

线程不安全

#### 扩容、拷贝、增加、删除时间复杂度空间复杂度

#### 实现

ArrayList的底层是用数组来实现的，默认第一次插入元素时创建大小为10的数组，超出限制时会增加50%的容量，并且数据以 System.arraycopy() 复制到新的数组，因此最好能给出数组大小的预估值。

按数组下标访问元素的性能很高，这是数组的基本优势。直接在数组末尾加入元素的性能也高，但如果按下标插入、删除元素，则要用 System.arraycopy() 来移动部分受影响的元素，性能就变差了，这是基本劣势。

### CopyOnWriteArrayList原理

CopyOnWriteArrayList是Java并发包里提供的并发类，简单来说它就是一个线程安全且读操作无锁的ArrayList。正如其名字一样，在写操作时会复制一份新的List，在新的List上完成写操作，然后再将原引用指向新的List。这样就保证了写操作的线程安全。

CopyOnWriteArrayList允许线程并发访问读操作，这个时候是没有加锁限制的，性能较高。而写操作的时候，则首先将容器复制一份，然后在新的副本上执行写操作，这个时候写操作是上锁的。结束之后再将原容器的引用指向新容器。注意，在上锁执行写操作的过程中，如果有需要读操作，会作用在原容器上。因此上锁的写操作不会影响到并发访问的读操作。

- 优点：读操作性能很高，因为无需任何同步措施，比较适用于读多写少的并发场景。在遍历传统的List时，若中途有别的线程对其进行修改，则会抛出ConcurrentModificationException异常。而CopyOnWriteArrayList由于其"读写分离"的思想，遍历和修改操作分别作用在不同的List容器，所以在使用迭代器进行遍历时候，也就不会抛出ConcurrentModificationException异常了。
- 缺点：一是内存占用问题，毕竟每次执行写操作都要将原容器拷贝一份，数据量大时，对内存压力较大，可能会引起频繁GC。二是无法保证实时性，Vector对于读写操作均加锁同步，可以保证读和写的强一致性。而CopyOnWriteArrayList由于其实现策略的原因，写和读分别作用在新老不同容器上，在写操作执行过程中，读不会阻塞但读取到的却是老容器的数据。

## Set

HashSet、TreeSet中的元素都是不能重复的，并且它们都是线程不安全的，二者的区别是：

1. HashSet中的元素可以是null，但TreeSet中的元素不能是null
2. HashSet不能保证元素的排列顺序，而TreeSet支持自然排序、定制排序两种排序的方式
3. HashSet底层是采用HashMap实现的，而TreeSet底层是采用红黑树实现的