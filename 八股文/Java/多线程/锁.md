# 锁

## 乐观锁与悲观锁

不是具体的“锁”，而是一种并发编程的基本概念

### 悲观锁

总是假设最坏的情况，每次去拿数据的时候都认为别人会修改

所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁

> Java中悲观锁是通过synchronized关键字或Lock接口来实现的

### 乐观锁

总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁

但是在更新的时候会判断一下在此期间别人有没有去操作这个数据

乐观锁适用于多读的应用类型，这样可以提高吞吐量。

#### 实现

* 版本号控制
* CAS

## 公平锁与非公平锁

根据线程获取锁的抢占机制来分

### 公平锁

多个线程按照申请锁的顺序来获取锁

### 非公平锁

多个线程获取锁的顺序并不是按照申请锁的顺序

有可能后申请的线程比先申请的线程优先获取锁

ReentrantLock 提供了公平锁和非公平锁的实现

- 公平锁：new ReentrantLock(true)
- 非公平锁：new ReentrantLock(false)

如果构造函数不传任何参数的时候，默认提供的是非公平锁

> synchronized 使用的是非公平锁，并且是不可设置
>
> 因为非公平锁的吞吐量大于公平锁，并且是主流操作系统线程调度的基本选择

### 为什么非公平锁吞吐量大

比如 A 占用锁的时候，B 请求获取锁，发现被 A 占用之后，堵塞等待被唤醒，这个时候 C 同时来获取 A 占用的锁，如果是公平锁 C 后来者发现不可用之后一定排在 B 之后等待被唤醒，而非公平锁则可以让 C 先用，在 B 被唤醒之前 C 已经使用完成，从而节省了 C 等待和唤醒之间的性能消耗

## 独占（互斥）锁和共享锁

### 互斥锁

任何时候都只有一个线程能执行资源操作

> 已被占用则睡眠

### 共享锁

可以同时被多个线程读取，但只能被一个线程修改

## 可重入锁

线程获取了该锁之后，可以无限次的进入该锁锁住的代码

## 分段锁

分段锁其实是一种锁的设计，并不是具体的一种锁

能够提升多并发程序的性能

其实就是相当于将容器分段配锁

## 锁升级

1.6前，synchronized是一个重量级锁，1.6后引入了偏向锁和轻量级锁

锁的4种状态

1. 无锁状态
2. 偏向锁状态
3. 轻量级锁状态
4. 重量级锁状态

![img](https://uploadfiles.nowcoder.com/images/20220224/4107856_1645690356869/1E93EF873A5A8C896878DBD7EB5E6C36)

四种状态会随着竞争的情况逐渐升级，且是不可逆的过程，即不可降级

> 这四种状态都不是Java语言中的锁，而是Jvm为了提高锁的获取与释放效率而做的优化(使用synchronized时)

### 偏向锁

指一段同步代码一直被一个线程访问，即不存在多个线程竞争时，那么后续访问该线程会自动获取锁，降低获取锁的代价

### 轻量级锁

当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程通过自旋的形式尝试获取锁，不会阻塞，提高性能

### 重量级锁

当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋到一定次数（默认10）的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁

重量级锁会让其他申请的线程进入阻塞，性能降低

## 自旋锁

尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁

* 好处是减少线程上下文切换的消耗

* 缺点是循环会消耗 CPU

  > 本身无法保证公平和可重入，会存在”线程饥饿“问题
  >
  > 但可以自行实现

#### 自旋锁和互斥锁

* 获取互斥锁的线程，如果锁已经被占用，则该线程将进入睡眠状态

* 获取自旋锁的线程则不会睡眠，而是一直循环等待锁释放

## 参考

[Java 中的各种锁和 CAS + 面试题](https://juejin.cn/post/6844904058315243527#heading-11)

[常见的Java锁总结](https://blog.51cto.com/u_14442094/2664125)