### 1. 如何实现子线程先执行，主线程再执行？

启动子线程后，立即调用该线程的join()方法，则主线程必须等待子线程执行完成后再执行。

### 2. 阻塞线程的方式

1. 线程调用sleep方法主动放弃所占用的处理器资源
2. 程调用了一个**阻塞式IO**方法，在该方法返回之前，该线程被阻塞
3. 线程试图获得一个**同步监视器**，但该同步监视器正被其他线程所持有
4. 线程在等待某个通知（notify）
5. 程序调用了线程的suspend()方法将该线程挂起，但这个方法容易导致死锁，所以应该尽量避免使用该方法

### 3. synchronized与Lock的区别

1. synchronized是Java关键字，在JVM层面实现加锁和解锁；Lock是一个接口，在代码层面实现加锁和解锁
2. synchronized可以用在代码块上、方法上；Lock只能写在代码里
3. synchronized在代码执行完或出现异常时自动释放锁；Lock不会自动释放锁，需要在finally中显示释放锁
4. synchronized会导致线程拿不到锁一直等待；Lock可以设置获取锁失败的超时时间
5. synchronized无法得知是否获取锁成功；Lock则可以通过tryLock得知加锁是否成功
6. synchronized锁可重入、不可中断、非公平；Lock锁可重入、可中断、可公平/不公平，并可以细分读写锁以提高效率

#### synchronized的底层实现原理

synchronized可以修饰静态方法，但是不能修饰静态代码块

#### ReentrantLock的实现原理

### 6. 不试用他俩如何保证线程安全？

### 9. 锁升级

### 10. 如何实现互斥锁

### 11. 分段锁是如何实现的

### 12. 读写锁

### 13. volatile关键字

#### 实现原理

