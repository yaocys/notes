# 多线程

---

## JUC

`java.util.concurrent`的缩写，是Java提供的并发包，包含了一些并发编程用到的基础组件，大致包括：

1. 原子更新
2. 锁和条件变量
3. 线程池
4. 阻塞队列
5. 并发容器
6. 同步器

### AQS

抽象队列同步器`AbstractQueuedSynchronizer`

### ThreadLocal

线程私有的局部变量存储容器，内部真正存取的是一个Map

> 经典使用场景是为每个线程分配一个JDBC连接Connection，可以保证每个线程都在各自的Connection上进行数据库的操作
>
> 还经常用于管理Session对话

#### 实现

Thread类中有个变量threadLocals，它的类型为ThreadLocal中的一个内部类ThreadLocalMap，这个类没有实现map接口，就是一个普通的Java类，但是实现的类似map的功能。每个线程都有自己的一个map

### 守护线程

Java线程分为用户线程和守护线程

- 守护线程是程序运行的时候在后台提供一种通用服务的线程。例如：垃圾回收线程

  所有用户线程停止，进程会停掉所有守护线程，退出程序（自动退出）
  
  > 一般是个死循环，例如：每日0点自动备份

* Java中把线程设置为守护线程的方法：在 start 线程之前调用线程的 setDaemon(true) 方法

### 线程和进程的区别

进程是一个应用程序

线程是进程中的一个执行单元

* 线程是轻量级的进程，一个进程可以包括一个或多个线程
* 线程是CPU调度的基本单位，进程是CPU分配资源的基本单位

### 1. 创建线程的3种方式

1. 继承Thread类

   定义Thread类的子类，并重写其`run()`方法（线程执行体）

   创建实例（线程对象），调用`start()`方法来启动线程

2. 实现Runnable接口

   定义Runnable接口的实现类，并实现该接口的`run()`方法（线程执行体）

   创建实例，并将其作为Thread的target来创建Thread对象（线程对象）

   调用线程对象的`start()`方法来启动线程

3. 实现Callable接口

   创建Callable接口的实现类，并实现`call()`方法（线程执行体）

   创建实例，并使用FutureTask类将其包装

   使用FutureTask对象作为Thread对象的target创建并启动新线程

   调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。

推荐使用后两种方法

优势

* 线程类只实现了接口，还可以继承其他类
* 多个线程可以共享同一个target对象，所以非常适合多个相同线程处理同一份资源的情况，从而可以将CPU、代码、数据分开，形成清晰的模型，较好地体现了面向对象的思想

劣势

* 编程稍微复杂，访问当前进程必须使用`Thread.currentThread()`方法

  > 继承Thread只需要this

##### runnable和callable区别

###### 相同点

* 都是接口
* 都可以编写多线程程序
* 都可以采用`Thread.start()`启动线程

###### 区别

* Callable规定重写的方法是`call()`，Runnable规定的重写方法是`run()`

* Runnable接口run方法无返回值；callable接口call方法有返回值，是个泛型，和Future、FutureTask配合可以获取异步执行的结果
* Runnable接口run方法只能抛出运行时异常且无法捕获处理；Callable接口call方法允许抛出异常，可以获取异常信息

> Callalbe接口支持返回执行结果，需要调用`FutureTask.get()`得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞

#### `run()`方法和`start()`方法的区别

调用`start()`方法启动线程时，系统会把该`run()`方法当成线程执行体来处理，==在JVM中开辟一块新的栈空间==，启动一个分支线程

如果直接调用线程对象的`run()`方法，系统把线程对象当成一个普通对象，而`run()`方法也是一个普通方法，而不是线程执行体。==不会去分配一个分支栈==，而是压栈帧到主栈中

### 2. 线程的生命周期-5种状态

新建、就绪、运行、阻塞、死亡

![image-20220702225604024](C:\Users\yaosu\AppData\Roaming\Typora\typora-user-images\image-20220702225604024.png)

当程序使用new关键字创建了一个线程之后，该线程就处于新建状态

当线程对象调用了start()方法之后，该线程处于就绪状态。至于该线程何时开始运行，取决于JVM里线程调度器的调度。

如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体，则该线程处于运行状态

当发生如下情况时，线程将会进入阻塞状态：

- 线程调用sleep()方法主动放弃所占用的处理器资源。
- 线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞。
- 线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有。
- 线程在等待某个通知（notify）。
- 程序调用了线程的suspend()方法将该线程挂起。但这个方法容易导致死锁，所以应该尽量避免使用该方法。

针对上面几种情况，当发生如下特定的情况时可以解除上面的阻塞，让该线程重新进入就绪状态：

- 调用sleep()方法的线程经过了指定时间。
- 线程调用的阻塞式IO方法已经返回。
- 线程成功地获得了试图取得的同步监视器。
- 线程正在等待某个通知时，其他线程发出了一个通知。
- 处于挂起状态的线程被调用了resume()恢复方法。

线程会以如下三种方式结束，结束后就处于死亡状态：

- run()或call()方法执行完成，线程正常结束。
- 线程抛出一个未捕获的Exception或Error。
- 直接调用该线程的stop()方法来结束该线程，该方法容易导致死锁，通常不推荐使用。

### 3. 如何实现线程同步

1. 同步方法
2. 同步代码块
3. ReentrantLock
4. volatile
5. 原子变量

### 4. Java多线程间的通信方式

1. `wait(`)、`notify()`、`notifyAll()`

   如果线程之间采用synchronized来保证线程安全

2. `await()`、`signal()`、`signalAll()`

   如果线程之间采用Lock来保证线程安全

3. BlockingQueue

#### `wait()`和`notify()`/`notifyAll()`

`wait()`、`notify()`、`notifyAll()`用来实现线程之间的通信，这三个方法都不是Thread类中所声明的方法，而是Object类中声明的方法

> 原因是每个对象都拥有锁，所以让当前线程等待某个对象的锁，当然应该通过这个对象来操作

`wait()`方法可以让当前线程释放对象锁并进入阻塞状态

`notify()`方法用于唤醒一个正在等待相应对象锁的线程，使其进入就绪队列，以便在当前线程释放锁后竞争锁，进而得到CPU的执行

`notifyAll()`方法用于唤醒所有正在等待相应对象锁的线程，使它们进入就绪队列

> 每个锁对象都有两个队列，一个是就绪队列，一个是阻塞队列。
>
> 就绪队列存储了已就绪（将要竞争锁）的线程，阻塞队列存储了被阻塞的线程。
>
> 当一个阻塞线程被唤醒后，才会进入就绪队列，进而等待CPU的调度。反之，当一个线程被wait后，就会进入阻塞队列，等待被唤醒。

#### `sleep()`和`wait()`

1. sleep是Thread类中的静态方法，wait是Object类中的成员方法
2. sleep可以在任何地方使用，wait只能在同步方法或同步代码块中使用
3. sleep不会释放锁；而wait会释放锁并需要通过`notify()`/`notifyAll()`重新获取锁

> sleep方法不能抛异常
>
> 子类异常必须小于父类，因为run方法在父类中没有抛出异常
>
> `interrupt()`方法会让方法报异常，依靠Java异常处理机制，进入catch体，然后往下走

### 多线程优势及风险

#### 价值

1. 有效发挥多核CPU的性能优势，提高CPU利用率

2. 与进程相比，线程的创建和切换开销更小，同时共享数据方面效率非常高

3. 防止阻塞

   从程序运行效率的角度来说，单核CPU不但不能发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文切换，而降低程序整体的效率

   但是单核CPU我们还是要应用多线程，就是为了防止阻塞，哪怕一条线程的代码执行读取数据阻塞，也不会影响其他任务的执行

3. 便于建模

   将大任务拆分为几个小任务，便于建模、理解、维护

## 线程安全

### 概述

#### 什么是线程安全

synchronized之后线程会释放占有的时间片，去锁池里找共享对象的锁，找到了就就绪继续抢夺，没找到就阻塞

### 如何解决

#### 1. synchronized关键字

synchronized可以修饰静态方法，不能修饰静态代码块

##### 底层实现



#### 2. Lock接口下的实现类

Lock是JUC包下的一个实现类

ReentrantLock是基于AQS（AbstractQueuedSynchronizer）实现的，是内部实现了两个队列的抽象类，分别是同步队列和条件队列

##### synchronized和Lock的区别

他俩都是悲观锁

1. synchronized是Java关键字，在JVM层面实现加锁和解锁；Lock是一个接口，在代码层面实现加锁和解锁

2. synchronized可以用在代码块和方法上；Lock只能写在代码里

3. synchronized在代码执行完成或出现异常时自动释放锁；Lock不会自动释放锁，需要在finally中显式释放锁

4. synchronized会导致线程拿不到锁一致等待，Lock可以设置锁获取失败的超时时间

5. synchronized无法得知锁是否获取成功；Lock可以通过tryLock得知加锁是否成功

6. synchronized锁可重入、不可中断、非公平

   Lock可重入、可中断、可公平也可不公平，并且可以细分读写锁以提高效率

#### 3. ThreadLocal

#### 4. volatile关键字

当一个变量被定义成volatile后，具备两项特性

1. 保证可见性
2. 禁止指令重排

> 不能替代锁

##### 实现

#### 5. 原子变量



版本号



## 多线程编程题



## 参考

* [50个必须要会的微服务面试题 - SegmentFault 思否](https://segmentfault.com/a/1190000020092884)
