# 索引

## 概述

索引是**旨在提高查询效率**、**存储于磁盘上**的**数据结构**

### 优点

### 缺点



## 分类

### 按数据结构

* B+树索引
* Hash索引
* Full-Text全文索引
* R-Tree索引

### 按物理存储

* 聚簇索引
* 非聚簇索引

> 都是B+树结构

### 逻辑角度

- 主键索引

  主键索引是一种特殊的唯一索引，不允许有空值

- 普通索引/单列索引

  每个索引只包含单个列，一个表可以有多个单列索引

- 多列索引/复合索引

  只有查询条件中使用了创建索引时的第一个字段，索引才会被使用。==遵循最左前缀原则==

  > 最左前缀原则：

- 唯一/非唯一索引

- 空间索引

  对空间数据类型的字段建立的索引

  > 空间数据类型：
  >
  > 1. `GEOMETRY`
  > 2. `POINT`
  > 3. `LINESTRING`
  > 4. `POLYGON`

## 结构

### B树

*为什么会出现B树这种数据结构*

传统平衡二叉树：AVL树、红黑树，在一般情况下查询性能非常好但当数据非常大时，内存不够用，大部分数据只能存放在磁盘上，只有需要的数据才加载到内存中。程序大部分时间阻塞在IO上

* 平衡二叉树是通过旋转来保持平衡的，而旋转是对整棵树的操作，部分加载到内存中则无法完成旋转操作

* 其次，平衡二叉树的高度相对较大为`log2 n`，**这样逻辑上很近的节点实际可能非常远，无法很好地利用磁盘预读（局部性原理）**

B树每个节点存多个值，且一次分多个范围区间，提升了搜索效率

### ==B+树==

B+树的不同之处在于

1. 所有的关键字存储字叶子节点出现，内部节点（非叶子节点）并不存储真正的data
2. 为所有的叶子节点增加了一个链指针

![img](https://upload-images.jianshu.io/upload_images/1446087-30b70aaa28403803.jpg?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

**B树的定义**

> 一种多路平衡查找树
>
> 类似于普通的平衡二叉树，但是允许每个节点有更多的子节点

* 每个节点最多有m-1个关键字（可以存有键值对）
* 根节点最少可以只有1个关键字
* 非根节点至少右m/2个关键字

> 即**根节点**关键字数量范围：1 <= k <= m-1
>
> **非根节点**关键字数量范围：m/2 <= k <= m-1

* **每个节点中的关键字都按从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，右子树中的所有关键字都大于它**
* **所有叶子节点都位于同一层**，或者说根节点到每个叶子节点的长度都相同
* 每个节点都存有索引和数据，也就key-value

> m表示阶数

**B树的插入**

需要判断当前节点key树是否满足定义，不满足则将这个节点分为左右两部分，中间节点放到父节点中

**特点**

1. 所有的键值（索引和数据）分布在整棵树中
2. 任何一个关键字出现且只出现一个节点中
3. 搜索可能在非叶子节点结束
4. 在关键字全集内做一次查找性能逼近二分查找

**B+树相对于B树的优势**

* 单一节点存储的元素更多，使得查询IO次数更少（**B+树单次磁盘 IO 的信息量大于B-树**）

  B+树更适合外部存储。内节点无data域，每个节点能索引的范围更大更精确

* 所有查询都要查找到叶子节点，查询性能稳定log2n（B树每个节点都可以查到数据，不稳定，最好O（1））

* 所有的叶子节点形成了一个有序链表，更加便于查找

* B+树叶节点两两相连可大大增加区间访问行，可使用在范围查询（而B树key和data在一起，无法区间查找）

### 聚簇索引和非聚簇索引

使用InnoDB存储引擎时，必须有且仅有一个聚集索引即主键索引

非聚集索引即普通索引任意多个

#### 区别

1. 聚簇索引中非叶子节点存储的是表的主键

   非聚簇索引中非叶子节点存储的是自己设置的索引字段对应的值

2. 聚簇索引的叶子节点，存储着当前表中每条记录的所有信息

   非聚簇索引的叶子节点，只存储当前记录对应的主键ID

#### 回表查询

如果是通过非主键（非聚簇）索引进行查询，select所要获取的字段不能通过非主键索引获取到，需要通过非主键索引获取到的主键，从聚集索引再次查询一遍，获取到所要查询的记录，这个查询的过程就是回表

1. 介绍一下数据库分页

   MySQL中可以使用`LIMIT`子句实现分页查询

   ```sql
   SELECT prod_name FROM products LIMIT 5;-- 返回前五行记录
   SELECT prod_name FROM products LIMIT 5,5;-- 从第五行开始，返回5行
   ```

   优化`LIMIT`分页

   在偏移量非常大的时候，例如`LIMIT 10000,20`，这时MySQL需要查询10020条记录后只返回最后20条，前面的10000条记录都将被抛弃，这样的代价是非常高的。

   >  如果所有的页面被访问的频率都相同，那么这样的查询平均需要访问半个表的数据

   要优化这种查询，要么在页面中限制分页的数量，要么优化大量偏移的性能

   最简单的办法就是：**尽可能地使用索引覆盖扫描**，而不是查询所有的列，然后根据需要做一次关联操作再返回所需的列。

   ```sql
   SELECT film_id,description FROM sakila.film ORDER BY title LIMIT 50,5;
   -- 如果这个表非常大，这个查询最好改成下面的样子
   SELECT film.film_id,film.description  FROM sakila.film INNER JOIN (  SELECT film_id FROM sakila.film ORDER BY title LIMIT 50,5 ) AS lim USING(film_id);
   -- 这里的“延迟关联”将大大提升查询效率，它让MySQL扫描尽可能少的页面，获取需要访问的记录后再根据关联列回原表查询需要的所有列
   -- 这个技术也可以优化关联查询中的LIMIT子句
   ```

   有时候也可以**将`LIMIT`查询转换为已知位置的查询**，让MySQL通过范围扫描获得对应的结果

   例如：如果在一个位置列上有索引，并且预先计算出了边界值，上面的查询就可以写为

   ```sql
   SELECT film_id,description FROM skila.film WHERE position BETWEEN 50 AND 54 ORDER BY position;
   ```

   > 对数据进行排名的问题也与此类似，但往往还会同时和GROUP BY混合使用，在这种情况下通常都需要预先计算并存储排名信息

   LIMIT和OFFSET的问题，其实是OFFSET的问题，它会导致MySQL扫描大量不需要的行然后再抛弃掉。如果可以使用书签记录上次取数的位置，那么下次就可以直接从该书签记录的位置开始扫描，这样就可以避免使用OFFSET。

   例如，若需要按照租赁记录做翻页，那么可以根据最新一条租赁记录向后追溯，这种做法可行是因为租赁记录的主键是单调增长的。首先使用下面的查询获得第一组结果：

   ```sql
   SELECT * FROM sakila.rental ORDER BY rental_id DESC LIMIT 20;
   ```

   假设上面的查询返回的是主键16049到16030的租赁记录，那么下一页查询就可以从16030这个点开始：

   ```sql
   SELECT * FROM sakila.rental  WHERE rental_id < 16030 ORDER BY rental_id DESC LIMIT 20;
   ```

   该技术的好处是无论翻页到多么后面，其性能都会很好。

4. SQL中怎么将行转成列的？

### 索引

1. ***说一说你对MySQL索引的理解***

   索引是一个单独的、存储在磁盘上的数据结构，包含着对数据表里所有记录的引用指针。使用索引可以快速找出在某个或多个列中有一特定值的行，所有MySQL列类型都可以被索引，对相关列使用索引是提高查询操作速度的最佳途径

   > 索引是在存储引擎中实现的，因此，每种存储引擎的索引都不一定完全相同，并且每种存储引擎也不一定支持所有索引类型
   >
   > MySQL中索引的存储类型有两种，即B-Tree和Hash，具体和表的存储引擎相关
   >
   > MyISAM和InnoDB存储引擎只支持BTREE索引
   >
   > MEMORY/HEAP存储引擎可以支持HASH和BTREE索引

   索引的优点主要有：

   1. 通过创建唯一索引，可以保证数据库表中每一行数据的唯一性
   2. 可以大大加快数据的查询速度，这也是创建索引的主要原因
   3. 在实现数据的参考完整性方面，可以加速表和表之间的连接
   4. 在使用分组和排序子句进行数据查询时，也可以显著减少查询中分组和排序的时间

   缺点：

   1. 创建和维护索引需要耗费时间，并且随着数据量的增加所耗费的时间也会增加
   2. 索引需要占据磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果有大量的索引，索引文件可能比数据文件更快达到最大文件尺寸
   3. 当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这降低了数据地维护速度

1. ***如何创建及保存MySQL的索引？***

   * 在创建表的时候创建索引

     ```sql
     CREATE TABLE table_name [col_name data_type] [UNIQUE|FULLTEXT|SPATIAL] [INDEX|KEY] [index_name] (col_name [length]) [ASC|DESC]
     ```

     > `INDEX`和`KEY`为同义词，两者作用相同，用来指定创建索引

   * 在已存在的表上创建索引

     ```sql
     ALTER TABLE table_name ADD  [UNIQUE|FULLTEXT|SPATIAL] [INDEX|KEY] [index_name] (col_name[length],...) [ASC|DESC]
     ```

     ```sql
     CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name  ON table_name (col_name [length],...) [ASC|DESC]
     ```

2. ***MySQL怎么判断要不要加索引？***

   建议按照以下原则：

   1. 当唯一性是某种数据本身的特征时，指定唯一索引。使用唯一索引能确保定义的列的数据完整性，以提高查询速度
   2. 在频繁进行排序或分组的列上建立索引，如果待排序的列有多个，可以在这些列上建立组合索引

3. ***只要创建了索引，就一定会走索引吗？***

   不一定

   例如：在使用组合索引的时候，如果没有遵从最左前缀的原则进行搜索，则索引是不起作用的

4. ***如何判断数据库的索引有没有生效？***

   可以使用`EXPLAIN`语句查看索引是否正在使用

   > 例如：
   >
   > ```sql
   > EXPLAIN SELECT * FROM book WHERE year_publication=1990;
   > ```
   >
   > `EXPLAIN`语句将为我们输出详细的SQL执行信息，其中：
   >
   > * possible_keys行给出了MySQL在搜索数据记录时可选用的各个索引。
   > * key行是MySQL实际选用的索引。
   >
   > 如果possible_keys行和key行都包含year_publication字段，则说明在查询时使用了该索引。

## 建立索引的原则

### 哪些情况创建

1. 主键自动建立唯一索引

2. 频繁作为查询条件的字段

3. 表中与其他表关联的字段，外键关系建立索引

4. 单键/组合索引的选择：高并发下倾向创建组合索引

5. 查询中排序的字段，能通过索引访问大幅提高排序速度

6. 查询中统计或分组字段

7. 当唯一性是某种数据本身的特征时，指定唯一索引。

   使用唯一索引需能确保定义的列的数据完整性，以提高查询速度。

### 哪些情况不创建

   1. 避免对**经常更新**的表进行过多的索引，并且索引中的列要尽可能少。

   2. **数据量小**的表最好不要使用索引

      由于数据较少，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果

   3. 在**条件表达式中经常用到的不同值较多的**列上建立索引

      在数据重复且分布均匀的列上不要建立索引

      例如：”性别“字段

   4. **频繁更新**的字段不创建索引

   5. `WHRER`条件里用不到的字段不创建索引
