# 事务

## 概述

### 特性

* A：原子性，整个数据库事务是不可分割的工作单位，要么全部成功，要么全部失败
* C：一执行，事务将数据库从一种状态转变为另一种一致的状态。在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏
* I：隔离性，要求每个读写事务的对象与其他事务的操作对象能相互分离，即该事务提交前对其他事务都不可见，这通常使用锁来实现
* D：持久性，事务一旦提交，其结果就是永久性的，即使发生宕机等故障，数据库也能将数据恢复。持久性保证的是事务系统的高可靠性，而不是高可用性

#### 实现



### 类型

* 扁平事务
* 带有保存点的扁平事务
* 链事务
* 嵌套事务（MySQL不支持）
* 分布式事务

## 事务的隔离级别

* 脏读

  A事务读取B事务尚未提交的数据，此时如果B事务发生错误并执行回滚操作，那么A事务读取到的数据就是脏数据

  例如：转账和取款

  <img src="https://ask.qcloudimg.com/http-save/yehe-1261315/femci8ahtm.jpeg?imageView2/2/w/1620" alt="img" style="zoom:50%;" />

* 不可重复读

  事务A在执行读取操作，由整个事务A比较大，前后读取同一条数据需要经历很长的时间 。而在事务A第一次读取数据，比如此时读取了小明的年龄为20岁，事务B执行更改操作，将小明的年龄更改为30岁，此时事务A第二次读取到小明的年龄时，发现其年龄是30岁，和之前的数据不一样了，也就是数据不重复了，系统不可以读取到重复的数据

  <img src="https://ask.qcloudimg.com/http-save/yehe-1261315/mjcm5vuqv7.png?imageView2/2/w/1620" alt="img" style="zoom: 50%;" />

* 幻读

  事务A在执行读取操作，需要两次统计数据的总量，前一次查询数据总量后，此时事务B执行了新增数据的操作并提交后，这个时候事务A读取的数据总量和之前统计的不一样，就像产生了幻觉一样，平白无故的多了几条数据

  <img src="https://ask.qcloudimg.com/http-save/yehe-1261315/551sc7wdwy.png?imageView2/2/w/1620" alt="img" style="zoom:50%;" />

##### 不可重复读和幻读的区别

不可重复读是读取了其他事务更改的数据，针对update操作

> 解决：使用行级锁

幻读是读取了其他事务新增的数据，针对insert和delete操作

> 解决：使用表级锁

### 数据库的隔离级别

| 隔离级别                     | 脏读 | 不可重复读 | 幻读 |
| ---------------------------- | ---- | ---------- | ---- |
| Read Uncommitted（读未提交） | √    | √          | √    |
| Read Committed（读提交）     |      | √          | √    |
| Repeatable read（可重复读）  |      |            | √    |
| Serializable（序列化）       |      |            |      |

> SQL Server、Oracle隔离级别为READ COMMITTED
>
> MySQL隔离级别为REPECTABLE READ

















