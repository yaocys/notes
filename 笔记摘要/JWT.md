# JSON Web Token

---

* 无状态 JWT（Stateless JWT）：包含 Session 数据的 JWT Token。Session 数据将被直接编码进 Token 内。
* 有状态 JWT（Stateful JWT）：包含 Session 引用或其 ID 的 JWT Token。Session 数据存储在服务端。
* Session token（又称 Session cookie）：标准的、可被签名的 Session ID，例如各类 Web 框架（译者注：包括 Laravel）内已经使用了很久的 Session 机制。Session 数据同样存储在服务端。

## 跨域认证问题

用户认证的一般流程：

> 1. 用户向服务器提交用户名和密码
> 2. 服务器验证成功后，在当前会话（session）中保存相关数据，如用户角色、登录权限等
> 3. 服务器向用户返回一个session_id，写入用户的cookie
> 4. 用户随后的每一次请求都会通过cookie将session_id传回服务器
> 5. 服务器收到session_id，据此找到前端前期保存的数据，由此得知用户的身份

这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。

举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？

一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。

另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。

## 原理

服务器认证以后，生成一个保存了用户信息的 JSON 对象，加密后发回给用户

以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。

为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名

服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。

## 数据结构

由点（.）分隔为三部分的一个字符串即`Header.Payload.Signature`

三个部分依次为：

> 1. Header（头部）：JSON对象——描述JWT的元数据
>
> 2. Payload（负载）：JSON对象——存放实际需要传递的数据
>
>    ==JWT默认不加密，不要把私密信息放在这里==
>
> 3. Signature（签名）：对前两个部分的签名，防止数据篡改
>
>    需要指定一个只有服务器知道的“密钥”（secret），然后使用Header里面指定的签名算法按照下面的公式生成签名
>
>    ```javascript
>    HMACSHA256(
>      base64UrlEncode(header) + "." +
>      base64UrlEncode(payload),
>      secret)
>    ```
>

前两个部分由Base64URL算法转成字符串

> Base64URL算法
>
> JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。
>
> Base64 有三个字符`+`、`/`和`=`，在 URL 里面有特殊含义，所将其替换掉：`=`被省略、`+`替换成`-`，`/`替换成`_` 

算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用"点"（`.`）分隔，就可以返回给用户。

## 使用方式

客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。

此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息`Authorization`字段里面。

```javascript
 Authorization: Bearer <token>
```

另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。

## 特点总结

1. JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。

2. JWT 不加密的情况下，不能将秘密数据写入 JWT。

3. JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。

4. **JWT 的最大缺点是：由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。**

   **也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。**

5. JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。

6. 为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。

## 适用场景

适用一次性验证，如防盗链/服务切换的身份令牌

1. 有效期短：因为不安全
2. 只希望被使用1次：无状态维护非常麻烦



## 比较登录方案

### JWT

* 优点：

* 缺点：

  1. 无法维护状态，续约与吊销需要额外的实现

     > 可以通过redis维护过期时间，但是这样就跟session差不多了

### Session

* 优点：
* 缺点：
  1. 需要解决跨域问题





要么

1. token没有过期时间+redis维护过期时间

   > token自带了过期时间的话，redis里面的过期时间就没有意义了，redis就算删了，已经颁发的token在有效期内还是能登录

2. token带过期时间+redis黑名单

   验证token时还要检查在不在黑名单里面

## 后记

payload会不会被签名加密？如何保证payload的安全性？有哪些加密算法？

